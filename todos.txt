Figure out string interpolation. See String_Literal_Expr#string=
This might be tricky. I can pull out all expressions
	"Testing `a + b * c` or `boo`".scan(/`([^`]+)`/).flatten # => ["a + b * c", "boo"]
So I think the interpreter needs to put each of these into a new lex+parse instance. then when it gets those results back, it can call #evaluate with each one to get the value.
The interpreter should also make a dictionary out of the extracted expressions. Then when each one is evaluated, store the output as its value. Later when they're being replaced into the string, it will be easy to replace even the complex expressions by string. Example of replacing:
	replacements = {
	  'name' => 'Locke',
	  'day' => 'tomorrow'
	}
	"`name`, today is `day`".gsub(/`([^`]+)`/) { replacements[$1] } # => "Locke, today is tomorrow"

Cannot escape strings.
'Test\'ing'
◼︎ Expected ''' but got ''
"Test\"ing"
◼︎ Expected '"' but got ''

Concatenating strings still broken for two strings.
@p 'Test ' + 'this'
"Test "this""

Operator overloading. Add new Operator_Token keyword, I need operators to be identifiable by pattern so that I can check for [Keyword_Token(operator), Operator_Token([] or other binary operator)]. Store it as a named Block_Expr aka function. The name is the operator. For Subscript should be named `[]`. So when interpreter encounters a Subscript_Expr, treat that as a Binary_Expr where left is subscript.left and the operator is dot, and the right is get_from_scope :functions, '[]'.
Any operator should be able to be overloaded, even ranges. Even `.`? That might be wild. So you can't change it on a global scope but you can on a class
Abc {
	operator . { other ->
		if other == 'new'
			@p 'called .new on `self`'
		}
	}
}
Thoughts today (without reading above thoughts): override operator with `operator` keyword. All operators have built in implementations by default but can be overloaded with `operator == { other -> }`, which gets executed on the receiver. To achieve that:
1) update parser to create named Block_Expr where name is the operator token
2) interpreter should store this under functions['=='] = Block_Construct or whatever
3) interpreter should call these functions when encountering them while parsing Binary_Exprs, since that's really the only place these operators will ever be present.

Apparently you can add members to an instance at any time by doing instance.whatever {} or instance.whatever = 'boo'. I kinda like that but it feels wrong, actually. Consider whether to keep this behavior.

Parser: when eating tokens into expressions that have a :name attribute, always store the token and not just token.string. That's currently how it is, but I need the actual, especially because Token has or should have cursor position info

Rethink how CONSTANTS are stored. Would it make sense for them to extend Assignment_Expr? Right now they're their own construct Enum_Constant_Expr and Enum_Collection_Expr

Issue interpreting. I wonder what to do about this. I plan to support .0, .1, etc as a binary expression to be able to easily access arrays by index (arr.1, arr.2, etc). That would be so nice. Once operator overloading works, you could overload . on Array and have it call through to []. Something like `operator . { right -> self.[right] }`.
Abc { boo = 'boo' }.new.boo
◼︎ "boo"
Abc { boo = 'boo' }.new.boo.1
◼︎ 0.1

Add autocomplete to REPL. See https://ruby-doc.org/stdlib-2.5.1/libdoc/readline/rdoc/Readline.html#method-c-completion_proc-3D-label-Examples

Implement builtin functions and variables for instances, those should be accessible by @member. eg) all classes might have `id =;`, to access it use `@id`. That way the internal members don't pollute the instance(aka the current runtime_scope). The end result is that you can use any name for members, even internal ones. And the internal ones can be accessed only by prepending the member with @

Generalize Interpreter#evaluate when Block_Call_Expr so that Block_Expr evaluation uses the same code to call the block inline

Generalize parsing expressions between parens. I think the function call ast parses parameters between parens, so go look there. When abstracted it can be reused for tuples. Also where Parser#make_ast checks curr? '(' I'm calling parse_expression again. But I think this is where I want to use #make_comma_separated_ast

Add support for inline conditional at end of lines because they reads nicely: `move() if xy else stop()`

Why are there two arrays storing ascii symbols? Ascii_Token::BINARY_OPERATORS and Ascii_Token::UNARY_OPERATORS, and in Lexer::SYMBOLS. When you change one, you have to update the operator precedence in parser, and also lexer DOUBLE_SYMBOLS

Pop last ast and replace with new ast to make conditionals (unless while if) work at the end of an expression. Pop last expression, it becomes the when_true of a Conditional_Expr

Implement, a ? b : c or is that unnecessary? I kind of like the `expr if expr else expr` syntax.

abc ?? xyz (abc if abc, otherwise xyz). This is basically how Ruby's || works. Maybe I don't need this since the interpreter uses Ruby's || when interpreting Em's ||

Extract documentation comments and todos from lexed tokens

Generate references into a /references folder somewhere, creating directories to match the code that was lexed. eg controllers/users_controller.e documents to references/controllers/users_controller.md

Should nil be a static object or just a string from the POV of the user? should it crash when something is nil?

The double reversing of @scopes in Interpreter#get_construct is probably inefficient, so maybe just get the index of current scope and use it to traverse up the scope stack in the reverse order?

Compositions and args/params at Interpreter#evaluate when Block_Expr

Use function signature in #get_construct and #set_construct? But I'm not sure how, since Function_Call_Expr only knows a function's name.

Double check why Identifier_Expr and Identifier_Token both have identical #constant?, #object?, and #member?

Clarity issue. Identifier_Expr/Identifier_Token #member? because it's not clear. Add #variable? and #function? and make #member? return `variable? or function?`

Consider identifiers starting with a number again like 1st, 2nd, 3rd?, 4th!, etc

Figure out how to call functions without parens like in Ruby. See Parser#make_function_call_ast

Parsing issue? `go(wtf =;)` parses to `fun_call(name: go, ["Arg(set(wtf=))"])`. This is an old comment from Parser#make_function_call_ast

Parser returns Nil_Expr when it parses `nil`. Should it work differently? I'm not sure yet

In both Lexer and Parser, create some kind of error message object that functions similarly to localization. Would be cool to allow you to customize the error messages. ERRORS(:some_error) could read errors from a custom file based on the current language, like errors/en.yml or something like that

Repl: prevent ctrl+c from terminating, and make it cancel the current input. Currently it cancels the input but preserves the input prior to cancelling.

Consider composition with members. Parser#make_ast prevents it

If calling func without parens, think about how to handle collisions between variable and func names

I like how Ruby has classes for builtin types, like TrueClass, FalseClass, Integer, etc. Reading through true_class.rb, it dawned on me that there's probably some preload.rb-like file that would declare `true = TrueClass.new` or something like that. I'm currently lexing a Boolean_Token when an identifier is 'true' or 'false', then parsing that into a Boolean_Literal_Expr, and finally interpreting Boolean_Literal_Expr using Boolean_Literal_Expr#to_bool

Clean up Lexer#LEX – there's a mix of methods and some inline creations right at the conditional. It would be nice to be consistent.

When interpreting from a main file, if encountering an undefined thing then maybe flag it somehow to be interpreted at the end when there is no more of the program to interpret
