##
  Opal Phyilosophies
  • indentation is only for methods and objects
  • files are objects
  • objects are classes and structs
  • therefore files can be classes or structs
  • double # is multiline comments
  • single # is single line comments
  • designed to be pleasant to look at
  • inspired by Ruby but with strict typing
##

# file objects may be given a name and type using the iam keyword. otherwise a global object is autogenerated using the directory path as its namespace and its name as the object name. so language/opel_lang would become Language.OpelLang where Language is the namespace and OpelLang is the object

# iam keyword is a declarator, only one per file, it cannot have a block and must be unindented

# iam object declaration without args
iam Opal: class

# constructor keyword (new) for object without args. if object has args, they must be here too
def new: Opal
end

# iam object declaration with args, no identifier names
iam Gem: struct(float)

def new: Gem(value: float)
end

# object declaration with namespace

iam Food.Sandwich: class # Food namespace
end

## obj keyword is used to declare classes and structs

  they differ from ‘iam’ because they can be used anywhere to create an object, while iam is exclusively used to designate the file as an object. obj declarations always come with a block because the block is it’s body. Unlike the iam keyword, whose body is the entire file.

##

# @ key symbol is used to bind arg values to variables, removingneed to write a constructor (def new)
obj Opal: class(title: str)
  title: str = @title
end

obj Opal: class(title: str)
  title: str

  def new(title: str)
    title = @title # use @ here as well, it helps to prevent name collisions
  end
end

# bonus @ feature: automatically generate the variables too
obj Opal: struct(@title: str)
end

# objects without any args
obj Sandwich: struct
end

obj TurkeySub: class(@slices: int)
  slices: int = @slices # takes precedence over the @ autobinding
end

## @ bindings order of precedence

  HIGHEST
  1. @ bindings in the constructor
  2. @ bindings in the variable declaration. eg) slice: int = @slices
  3. @ bindings in the object declaration. eg) obj TurkeySub: class(@slices: int)
  LOWEST

##

## functions

  must begin with `def` and end with `end`. a function signature looks like this:
  return_type(input_type, input_types...)

##

def square: int(value: int)
  self.args # [value: int]
  self.type # int(int)
end

def square_and_some: float(a: int)
  # how to store arg’d function
  square_maker: float(int)

  a * a / 4.815
end

def save: bool
  # method signature for a method with no args is just empty parens
  saver: bool()
end

def saved?: bool
  save()
end

def no_signature
  # these look like typical Ruby methods, but in Opal, they have no input or output types in the signature
end

## enums

  must begin with `enum` and end with ‘end’.
  can also have methods, but they are stateless methods which is perfectly fine.
  method return type must match enum type

##

enum DatOfWeek: str
  Monday # autogen as .Monday, capitalization is your choice
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
  Sunday
end

enum TokenType: int
  identifier # autogen as .identifier, capitalization is your choice
  literal = 2
end

enum CoolerType: str
  def smooth: str(value: int)
    'smooth [value]'
  end
end

## variables ##

# ways of using enums
first: TokenType = TokenType.literal
second: TokenType = .identifier
third: CoolerType = CoolerType.smooth(4)

# built in types

color: float4 = (1.0, 1.0, 1.0, 1.0)
result: int = multiply(4, 8)
year: int = 2023
buoyancy: float = 0.78
question: str = "how cool is that?"
single_quote_string: str = 'single quotes are valid too, and interpolate! [question]'
description: str # uninitialized
about_me: str = "I was created in [year]" # interpolation
k: range = 0..10
calculator: int(int, int) # func reference
some_integer: int = 4.8
some_float: float = 16.23
some_inferred_num := 1987 # := infers the type
day: string = day_of_week() # method parens must be present, even when no args
enabled?: bool = true # the ? is a valid character for variable and method names, but not class or struct names

# user defined types
assorted: Sandwich = new(2) # omit class or struct  name when "new"-ing if the type is declared

assorted2 := Sandwich(3) # include class or struct when inferring type, but omit new keyword

assorted3: Sandwich = Sandwich(4) # this is fine too, just more verbose
sandwiches: [Sandwich] = [## initialize your list of Sandwiches here ##]

# the type of an array is list

const day: str = 'Saturday'
const month: int = 7

## blocks, must begin with their respective keyword and finish with `end` ##

for some_collection_such_as_list
  it # keyword referring to the current item
  at # keyword referring to the current index
  stop # keyword to break out of the loop
  next # keyword to skip to the next iteration, maybe it should be called next?
end

for 10 # when a number is provided, it will loop that many times.
  it # eg) when looping 10, the it will be 1-10
  at # eg) when looping 10 the i will be 0-9
end

while locked?
  next # works here too
  stop # works here too
end

if condition
end

if locked? || enabled?
end

## special operators or keywords ##

## logging to console ##

! 'your log message'
!! 'your warning message'
!!! 'your error message'

! day, month
##
  comma separate to print multiple lines
  your choice of delimeter as long as:
    it is a single character
    not a letter or number
    not any of the reserved words,

  can even be just a whitespace.

##

sandwich?.meat # equivalent of Ruby &.
enabled??.lettuce # if identifier already contains a ? then add another to act as a null check

## interfaces

  variables must be declared on the object manually
  methods must be declared on the object manually if they are stubbed
  methods that are implemented are free to be used without being declared on the object

##

api SpaceBody
  mass: float
  def weight: float(float)

  def label: str
    “it weighs [mass]!”
  end
end

